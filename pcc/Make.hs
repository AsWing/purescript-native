-----------------------------------------------------------------------------
--
-- Module      :  Make
-- Copyright   :  (c) 2013-14 Phil Freeman, (c) 2014 Gary Burgess, and other contributors
-- License     :  MIT
--
-- Maintainer  :  Andy Arvanitis
-- Stability   :  experimental
-- Portability :
--
-- |
--
-----------------------------------------------------------------------------

{-# LANGUAGE DataKinds #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TemplateHaskell #-}

module Make
  ( Make(..)
  , runMake
  , buildMakeActions
  ) where

import Control.Monad
import Control.Monad.Error.Class (MonadError(..))
import Control.Monad.Trans.Except
import Control.Monad.Reader
import Control.Monad.Writer.Strict

import Data.FileEmbed (embedFile)
import Data.List (intercalate)
import Data.Maybe (fromMaybe)
import Data.String (fromString)
import Data.Time.Clock
import Data.Version (showVersion)
import qualified Data.Map as M
import qualified Data.ByteString.Lazy as B

import System.Directory (doesDirectoryExist, doesFileExist, getModificationTime, createDirectoryIfMissing)
import System.FilePath ((</>), takeDirectory, addExtension, dropExtension)
import System.IO.Error (tryIOError)

import qualified Language.PureScript as P
import qualified Language.PureScript.CodeGen.Cpp as CPP
import qualified Language.PureScript.CoreFn as CF
import qualified Paths_purescript as Paths

newtype Make a = Make { unMake :: ReaderT P.Options (WriterT P.MultipleErrors (ExceptT P.MultipleErrors IO)) a }
  deriving (Functor, Applicative, Monad, MonadIO, MonadError P.MultipleErrors, MonadWriter P.MultipleErrors, MonadReader P.Options)

runMake :: P.Options -> Make a -> IO (Either P.MultipleErrors (a, P.MultipleErrors))
runMake opts = runExceptT . runWriterT . flip runReaderT opts . unMake

makeIO :: (IOError -> P.ErrorMessage) -> IO a -> Make a
makeIO f io = do
  e <- liftIO $ tryIOError io
  either (throwError . P.singleError . f) return e

-- Traverse (Either e) instance (base 4.7)
traverseEither :: Applicative f => (a -> f b) -> Either e a -> f (Either e b)
traverseEither _ (Left x) = pure (Left x)
traverseEither f (Right y) = Right <$> f y

buildMakeActions :: FilePath
                 -> M.Map P.ModuleName (Either P.RebuildPolicy String)
                 -> Bool
                 -> P.MakeActions Make
buildMakeActions outputDir filePathMap usePrefix =
  P.MakeActions getInputTimestamp getOutputTimestamp readExterns codegen progress
  where

  getInputFile :: P.ModuleName -> FilePath
  getInputFile mn =
    let path = fromMaybe (error "Module has no filename in 'make'") $ M.lookup mn filePathMap in
    case path of
      Right path' -> path'
      Left _ -> error  "Module has no filename in 'make'"

  getInputTimestamp :: P.ModuleName -> Make (Either P.RebuildPolicy (Maybe UTCTime))
  getInputTimestamp mn = do
    let path = fromMaybe (error "Module has no filename in 'make'") $ M.lookup mn filePathMap
    traverseEither getTimestamp path

  getOutputTimestamp :: P.ModuleName -> Make (Maybe UTCTime)
  getOutputTimestamp mn = do

    let filePath = dotsTo '/' $ P.runModuleName mn
        fileBase = outputDir </> filePath </> (last . words . dotsTo ' ' $ P.runModuleName mn)
        srcFile = addExtension fileBase "cc"
--      headerFile = addExtension fileBase "hh"
        externsFile = outputDir </> filePath </> "externs.purs"
    min <$> getTimestamp srcFile <*> getTimestamp externsFile

  readExterns :: P.ModuleName -> Make (FilePath, B.ByteString)
  readExterns mn = do
    let path = outputDir </> (dotsTo '/' $ P.runModuleName mn) </> "externs.purs"
    (path, ) <$> readTextFile path

  codegen :: CF.Module CF.Ann -> P.Environment -> P.Externs -> P.SupplyT Make ()
  codegen m env exts = do
    let mn = CF.moduleName m
    let filePath = dotsTo '/' $ P.runModuleName mn
        fileBase = outputDir </> filePath </> (last . words . dotsTo ' ' $ P.runModuleName mn)
        srcFile = addExtension fileBase "cc"
        headerFile = addExtension fileBase "hh"
        externsFile = outputDir </> filePath </> "externs.purs"
        prefix = ["Generated by pcc version " ++ showVersion Paths.version | usePrefix]
    cpps <- CPP.moduleToCpp env m
    let (hdrs,srcs) = span (/= CPP.CppEndOfHeader) cpps
    psrcs <- CPP.prettyPrintCpp <$> pure srcs
    phdrs <- CPP.prettyPrintCpp <$> pure hdrs
    let src = unlines $ map ("// " ++) prefix ++ [psrcs]
        hdr = unlines $ map ("// " ++) prefix ++ [phdrs]

    lift $ do
      writeTextFile srcFile (fromString src)
      writeTextFile headerFile (fromString hdr)
      writeTextFile externsFile exts

      let supportDir = outputDir </> "PureScript"
      supportFilesExist <- dirExists supportDir
      when (not supportFilesExist) $ do
        writeTextFile (outputDir  </> "CMakeLists.txt") (fromString cmakeListsTxt)
        writeTextFile (supportDir </> "PureScript.hh") $ B.fromStrict $(embedFile "pcc/include/purescript.hh")
        writeTextFile (supportDir </> "map_key.hh")    $ B.fromStrict $(embedFile "pcc/include/map_key.hh")

      when (requiresForeign m) $ do
        let inputPath = dropExtension $ getInputFile mn
            hfile = addExtension inputPath "hh"
            sfile = addExtension inputPath "cc"
        hfileExists <- textFileExists hfile
        when (not hfileExists) (throwError . P.errorMessage $ P.MissingFFIModule mn)
        text <- readTextFile hfile
        writeTextFile (addExtension (fileBase ++ "_ffi") "hh") text
        sfileExists <- textFileExists sfile
        when (sfileExists) $ do
          text' <- readTextFile sfile
          writeTextFile (addExtension (fileBase ++ "_ffi") "cc") text'

  requiresForeign :: CF.Module a -> Bool
  requiresForeign = not . null . CF.moduleForeign

  dirExists :: FilePath -> Make Bool
  dirExists path = makeIO (const (P.SimpleErrorWrapper $ P.CannotReadFile path)) $ do
    doesDirectoryExist path

  textFileExists :: FilePath -> Make Bool
  textFileExists path = makeIO (const (P.SimpleErrorWrapper $ P.CannotReadFile path)) $ do
    doesFileExist path

  getTimestamp :: FilePath -> Make (Maybe UTCTime)
  getTimestamp path = makeIO (const (P.SimpleErrorWrapper $ P.CannotGetFileInfo path)) $ do
    exists <- doesFileExist path
    traverse (const $ getModificationTime path) $ guard exists

  readTextFile :: FilePath -> Make B.ByteString
  readTextFile path = makeIO (const (P.SimpleErrorWrapper $ P.CannotReadFile path)) $ B.readFile path

  writeTextFile :: FilePath -> B.ByteString -> Make ()
  writeTextFile path text = makeIO (const (P.SimpleErrorWrapper $ P.CannotWriteFile path)) $ do
    mkdirp path
    B.writeFile path text
    where
    mkdirp :: FilePath -> IO ()
    mkdirp = createDirectoryIfMissing True . takeDirectory

  -- | Render a progress message
  renderProgressMessage :: P.ProgressMessage -> String
  renderProgressMessage (P.CompilingModule mn) = "Compiling " ++ P.runModuleName mn

  progress :: P.ProgressMessage -> Make ()
  progress = liftIO . putStrLn . renderProgressMessage

dotsTo :: Char -> String -> String
dotsTo chr = map (\c -> if c == '.' then chr else c)

-- TODO: quick and dirty for now -- explicit file list would be better
cmakeListsTxt :: String
cmakeListsTxt = intercalate "\n" lines'
  where lines' = [ "cmake_minimum_required (VERSION 3.0)"
                 , "project (Main)"
                 , "file (GLOB_RECURSE SRCS *.cc)"
                 , "file (GLOB_RECURSE HDRS *.hh)"
                 , "add_executable (Main ${SRCS} ${HDRS})"
                 , "include_directories (${CMAKE_CURRENT_SOURCE_DIR})"
                 , "set (CMAKE_CXX_FLAGS ${CMAKE_CXX_FLAGS} \"-std=c++14 -DDEBUG\")"
                 ]
